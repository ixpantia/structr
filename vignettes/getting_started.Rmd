---
title: "Getting Started with structr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with structr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(structr)
```

## Introduction

The `structr` package allows you to parse JSON strings while strictly validating them against a predefined schema or structure. This ensures that the data conforms to your expectations regarding data types (integer, double, string, logical), nesting (objects, arrays), required fields, and optional (nullable) values.

The core validation logic is implemented in Rust for performance, leveraging the `serde` library, and made available in R through the `{extendr}` package.

This vignette provides a brief overview of the main workflow.

## Basic Workflow

Using `structr` involves three main steps:

1.  **Define the Schema:** Use the `s_*` functions (`s_map`, `s_vector`, `s_integer`, etc.) to describe the expected JSON structure and types. This results in an R list representing the schema.
2.  **Build the Structure:** Pass the schema definition to `build_structure()`. This function validates your schema *definition* and prepares an optimized internal representation for parsing.
3.  **Parse and Validate:** Use `parse_json()` with the input JSON string and the *built structure* object. If the JSON matches the structure, it returns the parsed R object (typically nested lists). If not, it throws a detailed error.

## Example 1: Simple Object

Let's define a structure for a simple user object and parse matching JSON.

```{r simple_object}
# 1. Define the schema
user_schema <- s_map(
  id = s_integer(),
  username = s_string(),
  is_active = s_logical()
)

# 2. Build the structure
user_structure <- build_structure(user_schema)
# `user_structure` is now ready for parsing

# 3. Prepare valid JSON
valid_json <- '{
  "id": 123,
  "username": "testuser",
  "is_active": true
}'

# 4. Parse and validate
parsed_data <- parse_json(valid_json, user_structure)

# Print the result
print(parsed_data)

# Check the structure of the parsed data
str(parsed_data)
```

The output is an R list with the correct types (`integer`, `character`, `logical`).

## Example 2: Nested Structures and Optional Fields

Structures can be nested, and fields can be marked as optional (meaning they can accept `null`).

```{r nested_optional}
# 1. Define a schema with nesting and an optional description
product_schema <- s_map(
  product_id = s_string(),
  details = s_map(
    name = s_string(),
    price = s_double()
  ),
  tags = s_vector(s_string()),
  description = s_optional(s_string()) # Can be string or null
)

# 2. Build the structure
product_structure <- build_structure(product_schema)

# 3. Parse JSON with the optional field present
json_with_desc <- '{
  "product_id": "XYZ-123",
  "details": {"name": "Gadget", "price": 19.99},
  "tags": ["tech", "new"],
  "description": "A useful gadget"
}'
parsed1 <- parse_json(json_with_desc, product_structure)
cat("Description when present:\n")
print(parsed1$description)

# 4. Parse JSON where the optional field is null
json_null_desc <- '{
  "product_id": "ABC-789",
  "details": {"name": "Widget", "price": 9.50},
  "tags": [],
  "description": null
}'
parsed2 <- parse_json(json_null_desc, product_structure)
cat("\nDescription when null:\n")
print(parsed2$description)
```

Note that `s_optional()` means the *value* can be `null`. By default, for `s_map`, the *key* itself must still be present in the JSON, even if its value is `null`. If the key is entirely missing, `parse_json` will usually throw a "missing field" error.

## Handling Errors

If the JSON doesn't match the structure, `parse_json()` throws an informative error.

```{r errors, error=TRUE}
# Use the simple user_structure from Example 1

# Error: Type mismatch (id should be integer, not string)
json_type_error <- '{ "id": "123", "username": "badtype", "is_active": true }'
try(parse_json(json_type_error, user_structure))


# Error: Missing required field (username is missing)
json_missing_field <- '{ "id": 456, "is_active": false }'
try(parse_json(json_missing_field, user_structure))


# Error: Extra field (email is not defined in the schema)
json_extra_field <- '{
  "id": 789, "username": "extra", "is_active": true, "email": "a@b.com"
}'
try(parse_json(json_extra_field, user_structure))

# Error: Invalid JSON syntax
json_syntax_error <- '{ "id": 1 ' # Missing closing brace
try(parse_json(json_syntax_error, user_structure))
```

## Next Steps

This vignette covered the basic usage of `structr`. For more details on specific functions and validation rules, consult the help pages:

*   `?parse_json`
*   `?build_structure`
*   `?s_map`, `?s_vector`, `?s_integer`, `?s_double`, `?s_string`, `?s_logical`, `?s_optional`, `?s_date`

