[{"path":"https://ixpantia.github.io/structr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 structr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"JSON Parsing Performance Benchmark","text":"document benchmarks performance different R packages parsing JSON strings R objects. compare: structr: Parses JSON simultaneously validates predefined schema (implemented Rust using serde simd-json). jsonlite: widely used, robust JSON parser (implemented C). rjson: Another JSON parser (implemented C). RJSONIO: versatile JSON parser, often used interfacing web APIs (implemented C). RcppSimdJson: high-performance JSON parser based simdjson, known speed efficiency (implemented C++). goal compare parsing speed across wider range JSON structures, simple atomic values large arrays deeply nested objects.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"benchmark-setup","dir":"Articles","previous_headings":"","what":"Benchmark Setup","title":"JSON Parsing Performance Benchmark","text":"test several scenarios representing common challenging JSON structures. structr, pre-build required structure definitions outside timed benchmark loop, reflecting typical usage (define structure , parse many times).","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"disclaimer","dir":"Articles","previous_headings":"Benchmark Setup","what":"Disclaimer","title":"JSON Parsing Performance Benchmark","text":"reading vignette GitHub Pages, benchmarks ran GitHub Actions. results differ every time run depending many factors. want true realistic benchmark, run code environment.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"json-data-and-structr-schemas","dir":"Articles","previous_headings":"Benchmark Setup","what":"JSON Data and structr Schemas","title":"JSON Parsing Performance Benchmark","text":"schemas JSON objects defined source code document. Since values can long, hidden final output, however, fully available source code.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"benchmarking-parameters","dir":"Articles","previous_headings":"Benchmark Setup","what":"Benchmarking Parameters","title":"JSON Parsing Performance Benchmark","text":"","code":"# Number of times to run each benchmark expression # Adjust down for slower scenarios if needed benchmark_times_fast <- 1000 benchmark_times_medium <- 500 benchmark_times_slow <- 100  # Unit for reporting timings benchmark_unit_fast <- \"us\" # microseconds benchmark_unit_medium <- \"ms\" # milliseconds benchmark_unit_slow <- \"ms\" # milliseconds"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"benchmark-results","dir":"Articles","previous_headings":"","what":"Benchmark Results","title":"JSON Parsing Performance Benchmark","text":"now run benchmarks scenario. plots show distribution execution times (lower better). Note Y-axis often logarithmic scale due potentially large performance differences. use check = \"equal\" wrap fromJSON calls try() complex cases strict equality might fail due floating point differences minor structural variations parsers, focusing instead raw speed.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-1-simple-flat-object","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 1: Simple Flat Object","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_simple_object <- microbenchmark(   structr = structr::parse_json(json_simple_object, structr_simple_object),   jsonlite = jsonlite::fromJSON(json_simple_object, simplifyDataFrame = FALSE),   rjson = rjson::fromJSON(json_simple_object),   RJSONIO = RJSONIO::fromJSON(json_simple_object, simplify = FALSE),   RcppSimdJson = RcppSimdJson::fparse(json_simple_object),   times = benchmark_times_fast, unit = benchmark_unit_fast, check = \"equal\" ) print_and_plot(bm_simple_object,   title = \"Scenario 1: Simple Flat Object Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq      mean  median      uq      max neval ##       structr  4.429  7.1745  9.089279  9.1230 10.2605   45.445  1000 ##      jsonlite 42.120 50.1350 59.516765 54.0720 63.4590 2606.993  1000 ##         rjson 27.913 36.3635 41.853449 41.3180 45.3810  108.634  1000 ##       RJSONIO 33.774 43.4070 48.786924 47.7505 52.7145  171.811  1000 ##  RcppSimdJson 21.120 27.8780 32.452443 31.5550 35.1820  139.712  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-2-simple-array-integers-50-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 2: Simple Array (Integers, 50 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_simple_array_int <- microbenchmark(   structr = structr::parse_json(json_simple_array_int, structr_simple_array_int),   jsonlite = jsonlite::fromJSON(json_simple_array_int), # simplify = TRUE default good here   rjson = rjson::fromJSON(json_simple_array_int),   RJSONIO = RJSONIO::fromJSON(json_simple_array_int), # simplify = TRUE default good here   RcppSimdJson = RcppSimdJson::fparse(json_simple_array_int),   times = benchmark_times_fast, unit = benchmark_unit_fast, check = \"equal\" )  print_and_plot(bm_simple_array_int,   title = \"Scenario 2: Simple Array (Integers) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq     mean  median      uq      max neval ##       structr  3.769  6.0675  7.47874  7.6500  8.6170   25.780  1000 ##      jsonlite 32.602 38.3680 42.67619 41.7390 44.3840  105.888  1000 ##         rjson 31.770 37.8315 43.69839 43.3015 46.4025  110.147  1000 ##       RJSONIO 44.394 53.3000 58.58510 57.4380 60.9850  123.672  1000 ##  RcppSimdJson 21.471 25.9745 33.49190 30.1175 32.7420 3119.990  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-3-simple-array-strings-26-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 3: Simple Array (Strings, 26 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_simple_array_str <- microbenchmark(   structr = structr::parse_json(json_simple_array_str, structr_simple_array_str),   jsonlite = jsonlite::fromJSON(json_simple_array_str),   rjson = rjson::fromJSON(json_simple_array_str),   RJSONIO = RJSONIO::fromJSON(json_simple_array_str),   RcppSimdJson = RcppSimdJson::fparse(json_simple_array_str),   times = benchmark_times_fast, unit = benchmark_unit_fast, check = \"equal\" )  print_and_plot(bm_simple_array_str,   title = \"Scenario 3: Simple Array (Strings) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq     mean  median      uq      max neval ##       structr  4.078  6.2570  7.50309  7.6090  8.4960   24.716  1000 ##      jsonlite 25.848 30.4620 33.88277 33.7080 35.8870   70.722  1000 ##         rjson 29.365 35.7370 40.15605 40.1900 42.8550  101.249  1000 ##       RJSONIO 40.746 47.5590 51.83998 51.4655 54.9125  142.125  1000 ##  RcppSimdJson 21.641 26.3145 32.45551 29.8455 32.1600 2761.380  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-4-nested-object","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 4: Nested Object","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_nested_object <-   microbenchmark(     structr = structr::parse_json(json_nested_object, structr_nested_object),     jsonlite = jsonlite::fromJSON(json_nested_object, simplifyVector = FALSE),     rjson = rjson::fromJSON(json_nested_object),     RJSONIO = RJSONIO::fromJSON(json_nested_object, simplify = FALSE), # avoid matrix/df conversion     RcppSimdJson = RcppSimdJson::fparse(json_nested_object),     times = benchmark_times_fast, unit = benchmark_unit_fast, check = NULL # Disable check due to potential minor diffs   )  print_and_plot(bm_nested_object,   title = \"Scenario 4: Nested Object Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq     mean  median      uq      max neval ##       structr 16.752 21.7605 25.16669 25.2620 27.1010   88.224  1000 ##      jsonlite 26.029 33.9280 38.19167 37.6955 40.1600   79.379  1000 ##         rjson 41.097 50.6345 59.58850 56.4200 60.4025 2743.528  1000 ##       RJSONIO 53.931 64.5355 71.52599 69.0990 74.6740  162.393  1000 ##  RcppSimdJson 29.586 36.9340 43.29700 43.2100 46.5670  119.163  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-5-array-of-simple-objects-100-objects","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 5: Array of Simple Objects (100 Objects)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_array_of_objects <-   microbenchmark(     structr = structr::parse_json(json_array_of_objects, structr_array_of_objects),     jsonlite = jsonlite::fromJSON(json_array_of_objects, simplifyVector = FALSE, simplifyDataFrame = FALSE), # Force list output     rjson = rjson::fromJSON(json_array_of_objects),     RJSONIO = RJSONIO::fromJSON(json_array_of_objects, simplify = FALSE), # Results in list of lists     RcppSimdJson = RcppSimdJson::fparse(json_array_of_objects),     times = benchmark_times_medium, unit = benchmark_unit_medium, check = NULL   ) print_and_plot(bm_array_of_objects,   title = \"Scenario 5: Array of 100 Objects Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq       mean    median        uq      max neval ##       structr 0.170228 0.2153470 0.22994897 0.2243940 0.2391865 1.747199   500 ##      jsonlite 0.121286 0.1539020 0.16594439 0.1620970 0.1677470 3.367251   500 ##         rjson 0.162954 0.1764045 0.19189677 0.1884065 0.2059890 0.258812   500 ##       RJSONIO 0.251108 0.2716010 0.28870706 0.2795420 0.2899105 3.649697   500 ##  RcppSimdJson 0.055905 0.0682375 0.08127627 0.0768130 0.0947020 0.152715   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-6-large-array-of-simple-objects-1000-objects","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 6: Large Array of Simple Objects (1000 Objects)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_large_array_of_objects <-   microbenchmark(     structr = structr::parse_json(json_large_array_of_objects, structr_large_array_of_objects),     jsonlite = jsonlite::fromJSON(json_large_array_of_objects, simplifyVector = FALSE, simplifyDataFrame = FALSE),     rjson = rjson::fromJSON(json_large_array_of_objects),     RJSONIO = RJSONIO::fromJSON(json_large_array_of_objects, simplify = FALSE),     RcppSimdJson = RcppSimdJson::fparse(json_large_array_of_objects),     times = benchmark_times_medium,     unit = benchmark_unit_medium,     check = NULL # Disable check   )  print_and_plot(bm_large_array_of_objects,   title = \"Scenario 6: Array of 1000 Objects Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq      mean    median       uq       max neval ##       structr 2.039634 2.2578115 2.4951142 2.3678660 2.508825 13.940752   500 ##      jsonlite 1.392448 1.4365900 1.5517232 1.4628990 1.563381  6.626530   500 ##         rjson 1.346752 1.3941400 1.5532192 1.4241920 1.506165 11.865242   500 ##       RJSONIO 2.021700 2.1895545 2.3005874 2.2062650 2.279511  7.433315   500 ##  RcppSimdJson 0.334354 0.3544965 0.4267317 0.3714625 0.406188  3.952022   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-7-large-integer-array-10000-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 7: Large Integer Array (10,000 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_large_array_int <-   microbenchmark(     structr = structr::parse_json(json_large_array_int, structr_large_array_int),     jsonlite = jsonlite::fromJSON(json_large_array_int),     rjson = rjson::fromJSON(json_large_array_int),     RJSONIO = RJSONIO::fromJSON(json_large_array_int),     RcppSimdJson = RcppSimdJson::fparse(json_large_array_int),     times = benchmark_times_medium,     unit = benchmark_unit_medium,     check = \"equal\"   ) print_and_plot(bm_large_array_int,   title = \"Scenario 7: Large Integer Array (10k) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq      mean   median        uq       max neval ##       structr 0.189384 0.1978090 0.2145628 0.205919 0.2274790  0.729841   500 ##      jsonlite 2.299479 2.6265340 2.7824669 2.699009 2.8016865  7.170655   500 ##         rjson 1.043647 1.0689490 1.1909223 1.081812 1.1088935 11.211392   500 ##       RJSONIO 2.576846 2.6060210 2.7007530 2.622572 2.6457650  7.358586   500 ##  RcppSimdJson 0.189513 0.2041955 0.2207457 0.211304 0.2387155  0.353519   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-8-large-string-array-10000-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 8: Large String Array (10,000 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_large_array_str <-   microbenchmark(     structr = structr::parse_json(json_large_array_str, structr_large_array_str),     jsonlite = jsonlite::fromJSON(json_large_array_str),     rjson = rjson::fromJSON(json_large_array_str),     RJSONIO = RJSONIO::fromJSON(json_large_array_str),     RcppSimdJson = RcppSimdJson::fparse(json_large_array_str),     times = benchmark_times_medium,     unit = benchmark_unit_medium,     check = \"equal\"   ) print_and_plot(bm_large_array_str,   title = \"Scenario 8: Large String Array (10k) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq      mean    median        uq       max neval ##       structr 0.677746 0.6952935 0.7146474 0.7059030 0.7333990  1.168000   500 ##      jsonlite 2.250689 2.3831465 2.5624123 2.4560420 2.6109010  7.343960   500 ##         rjson 1.322558 1.3707325 1.4673928 1.3977430 1.4261815  6.315381   500 ##       RJSONIO 3.471897 3.5220150 3.6579798 3.5443470 3.5749445 11.932629   500 ##  RcppSimdJson 0.638051 0.6575825 0.6817317 0.6708325 0.7040545  1.136080   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-9-deeply-nested-object-10-levels","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 9: Deeply Nested Object (10 levels)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_deep_nest <- microbenchmark(   structr = structr::parse_json(json_deep_nest, structr_deep_nest),   jsonlite = jsonlite::fromJSON(json_deep_nest, simplifyVector = FALSE, simplifyDataFrame = FALSE),   rjson = rjson::fromJSON(json_deep_nest),   RJSONIO = RJSONIO::fromJSON(json_deep_nest, simplify = FALSE),   RcppSimdJson = RcppSimdJson::fparse(json_deep_nest),   times = benchmark_times_fast,   unit = benchmark_unit_fast,   check = \"equal\" ) print_and_plot(bm_deep_nest,   title = \"Scenario 9: Deeply Nested Object (10 Levels) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq     mean  median      uq      max neval ##       structr 12.283 15.9200 17.73371 17.7880 19.2005   40.947  1000 ##      jsonlite 16.842 20.1125 22.76351 22.8130 24.3250   71.133  1000 ##         rjson 29.836 35.3860 44.40679 40.4155 43.0050 4327.040  1000 ##       RJSONIO 37.450 44.7990 49.20665 48.8560 51.8565  173.023  1000 ##  RcppSimdJson 23.714 28.3330 32.10450 32.2350 34.4200   72.916  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-10-wide-object-100-fields","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 10: Wide Object (100 fields)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_wide_object <- microbenchmark(   structr = structr::parse_json(json_wide_object, structr_wide_object),   jsonlite = jsonlite::fromJSON(json_wide_object, simplifyVector = FALSE, simplifyDataFrame = FALSE),   rjson = rjson::fromJSON(json_wide_object),   RJSONIO = RJSONIO::fromJSON(json_wide_object, simplify = FALSE),   RcppSimdJson = RcppSimdJson::fparse(json_wide_object),   times = benchmark_times_medium,   unit = benchmark_unit_medium,   check = \"equal\" ) print_and_plot(bm_wide_object,   title = \"Scenario 10: Wide Object (100 Fields) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq       mean    median        uq      max neval ##       structr 0.059240 0.0677715 0.07257593 0.0720840 0.0750650 0.117350   500 ##      jsonlite 0.039935 0.0495670 0.05385760 0.0534690 0.0565950 0.107130   500 ##         rjson 0.062907 0.0725450 0.07915046 0.0789070 0.0833910 0.181629   500 ##       RJSONIO 0.082244 0.0912150 0.10898195 0.0975065 0.1034830 4.972184   500 ##  RcppSimdJson 0.033423 0.0406105 0.04678831 0.0468470 0.0512155 0.099455   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"summary-across-scenarios","dir":"Articles","previous_headings":"","what":"Summary Across Scenarios","title":"JSON Parsing Performance Benchmark","text":"Let’s combine median times scenarios visualize relative performance. convert times microseconds (us) comparison.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"JSON Parsing Performance Benchmark","text":"structr competes well every JSON parsing library added benefit schema validation parsing.","code":""},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with structr","text":"structr package allows parse JSON strings strictly validating predefined schema structure. ensures data conforms expectations regarding data types (integer, double, string, logical), nesting (objects, arrays), required fields, optional (nullable) values. core validation logic implemented Rust performance, leveraging serde library, made available R {extendr} package. vignette provides brief overview main workflow.","code":""},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic Workflow","title":"Getting Started with structr","text":"Using structr involves three main steps: Define Schema: Use s_* functions (s_map, s_vector, s_integer, etc.) describe expected JSON structure types. results R list representing schema. Build Structure: Pass schema definition build_structure(). function validates schema definition prepares optimized internal representation parsing. Parse Validate: Use parse_json() input JSON string built structure object. JSON matches structure, returns parsed R object (typically nested lists). , throws detailed error.","code":""},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"example-1-simple-object","dir":"Articles","previous_headings":"","what":"Example 1: Simple Object","title":"Getting Started with structr","text":"Let’s define structure simple user object parse matching JSON. output R list correct types (integer, character, logical).","code":"# 1. Define the schema user_schema <- s_map(   id = s_integer(),   username = s_string(),   is_active = s_logical() )  # 2. Build the structure user_structure <- build_structure(user_schema) # `user_structure` is now ready for parsing  # 3. Prepare valid JSON valid_json <- '{   \"id\": 123,   \"username\": \"testuser\",   \"is_active\": true }'  # 4. Parse and validate parsed_data <- parse_json(valid_json, user_structure)  # Print the result print(parsed_data) #> $id #> [1] 123 #>  #> $username #> [1] \"testuser\" #>  #> $is_active #> [1] TRUE  # Check the structure of the parsed data str(parsed_data) #> List of 3 #>  $ id       : int 123 #>  $ username : chr \"testuser\" #>  $ is_active: logi TRUE"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"example-2-nested-structures-and-optional-fields","dir":"Articles","previous_headings":"","what":"Example 2: Nested Structures and Optional Fields","title":"Getting Started with structr","text":"Structures can nested, fields can marked optional (meaning can accept null). Note s_optional() means value can null. default, s_map, key must still present JSON, even value null. key entirely missing, parse_json usually throw “missing field” error.","code":"# 1. Define a schema with nesting and an optional description product_schema <- s_map(   product_id = s_string(),   details = s_map(     name = s_string(),     price = s_double()   ),   tags = s_vector(s_string()),   description = s_optional(s_string()) # Can be string or null )  # 2. Build the structure product_structure <- build_structure(product_schema)  # 3. Parse JSON with the optional field present json_with_desc <- '{   \"product_id\": \"XYZ-123\",   \"details\": {\"name\": \"Gadget\", \"price\": 19.99},   \"tags\": [\"tech\", \"new\"],   \"description\": \"A useful gadget\" }' parsed1 <- parse_json(json_with_desc, product_structure) cat(\"Description when present:\\n\") #> Description when present: print(parsed1$description) #> [1] \"A useful gadget\"  # 4. Parse JSON where the optional field is null json_null_desc <- '{   \"product_id\": \"ABC-789\",   \"details\": {\"name\": \"Widget\", \"price\": 9.50},   \"tags\": [],   \"description\": null }' parsed2 <- parse_json(json_null_desc, product_structure) cat(\"\\nDescription when null:\\n\") #>  #> Description when null: print(parsed2$description) #> NULL"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"handling-errors","dir":"Articles","previous_headings":"","what":"Handling Errors","title":"Getting Started with structr","text":"JSON doesn’t match structure, parse_json() throws informative error.","code":"# Use the simple user_structure from Example 1  # Error: Type mismatch (id should be integer, not string) json_type_error <- '{ \"id\": \"123\", \"username\": \"badtype\", \"is_active\": true }' try(parse_json(json_type_error, user_structure)) #> Error in parse_json(json_type_error, user_structure) :  #>   ExpectedSigned at character 0   # Error: Missing required field (username is missing) json_missing_field <- '{ \"id\": 456, \"is_active\": false }' try(parse_json(json_missing_field, user_structure)) #> Error in parse_json(json_missing_field, user_structure) :  #>   Serde(\"missing field `username`\") at character 0   # Error: Extra field (email is not defined in the schema) json_extra_field <- '{   \"id\": 789, \"username\": \"extra\", \"is_active\": true, \"email\": \"a@b.com\" }' try(parse_json(json_extra_field, user_structure)) #> Error in parse_json(json_extra_field, user_structure) :  #>   Serde(\"unknown field `email`, expected one of `username`, `is_active`, `id`\") at character 0  # Error: Invalid JSON syntax json_syntax_error <- '{ \"id\": 1 ' # Missing closing brace try(parse_json(json_syntax_error, user_structure)) #> Error in parse_json(json_syntax_error, user_structure) :  #>   Syntax at character 8 ('1')"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with structr","text":"vignette covered basic usage structr. details specific functions validation rules, consult help pages: ?parse_json ?build_structure ?s_map, ?s_vector, ?s_integer, ?s_double, ?s_string, ?s_logical, ?s_optional, ?s_date","code":""},{"path":"https://ixpantia.github.io/structr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"ixpantia, SRL. Copyright holder. Andres Quintero. Author, maintainer. authors dependency Rust crates. Contributor.           see inst/AUTHORS file details","code":""},{"path":"https://ixpantia.github.io/structr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Quintero (2025). structr: Strictly Typed JSON Parsing Validation. R package version 0.1.0.9000, https://github.com/ixpantia/structr.","code":"@Manual{,   title = {structr: Strictly Typed JSON Parsing and Validation},   author = {Andres Quintero},   year = {2025},   note = {R package version 0.1.0.9000},   url = {https://github.com/ixpantia/structr}, }"},{"path":[]},{"path":"https://ixpantia.github.io/structr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Strictly Typed JSON Parsing and Validation","text":"structr provides robust efficient way parse JSON data R strictly validating user-defined schema. ensures incoming JSON conforms expected structures (objects, arrays, nesting) also adheres specific data types (integer, double, string, logical, optional/nullable). core logic implemented Rust using highly performant serde simd_json crates (accessed via {extendr}), offering significant speed advantages traditional R methods, especially validation required.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Strictly Typed JSON Parsing and Validation","text":"Schema Definition: Define expected JSON structures using intuitive R functions (s_map, s_vector, s_integer, s_double, s_string, s_logical, s_optional). Strict Validation: Enforces type correctness, presence required fields, nesting, handles null values via s_optional. default, extra fields objects cause errors. High Performance: Faster base R jsonlite validated parsing, validation integrated Rust parsing process. Informative Errors: Provides detailed messages pinpointing location nature validation failures.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"missing--planned-features","dir":"","previous_headings":"","what":"Missing / Planned Features","title":"Strictly Typed JSON Parsing and Validation","text":"JSON Serialization (R object -> JSON string). Custom validation rules/functions. Built-support complex types (e.g., dates, enums).","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"performance-advantage","dir":"","previous_headings":"","what":"Performance Advantage","title":"Strictly Typed JSON Parsing and Validation","text":"Unlike jsonlite::fromJSON focuses flexible parsing, structr::parse_json simultaneously parses validates predefined structure. often results significantly faster execution times validation requirement, checks integrated high-performance Rust parsing layer (simd_json). avoids overhead parsing flexible R object validating separately.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Strictly Typed JSON Parsing and Validation","text":"Prerequisites: need Rust compiler (rustc) package manager (cargo) installed. easiest way via rustup: Install structr:","code":"# Install rustup (interactive installer) curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Follow instructions. Ensure Rust >= 1.70 (check DESCRIPTION) # Requires 'remotes' package: install.packages(\"remotes\") remotes::install_github(\"ixpantia/structr\")  # Or, once on CRAN: # install.packages(\"structr\")"},{"path":"https://ixpantia.github.io/structr/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Strictly Typed JSON Parsing and Validation","text":"workflow involves three steps: Define Schema: Use s_* functions. Build Structure: Call build_structure() schema. Parse & Validate: Call parse_json() JSON string built structure.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"example-1-simple-object","dir":"","previous_headings":"Quick Start","what":"Example 1: Simple Object","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"library(structr)  # 1. Define Schema user_schema <- s_map(   id = s_integer(),   username = s_string(),   is_active = s_logical() )  # 2. Build Structure user_structure <- build_structure(user_schema)  # 3. Parse Valid JSON valid_json <- '{\"id\": 123, \"username\": \"testuser\", \"is_active\": true}' parsed_data <- parse_json(valid_json, user_structure)  print(parsed_data) # Output: list(id = 123L, username = \"testuser\", is_active = TRUE) str(parsed_data) # Output: Shows correct R types (integer, character, logical)"},{"path":"https://ixpantia.github.io/structr/index.html","id":"example-2-nesting-and-optional-fields","dir":"","previous_headings":"Quick Start","what":"Example 2: Nesting and Optional Fields","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"# 1. Define Schema product_schema <- s_map(   product_id = s_string(),   details = s_map(name = s_string(), price = s_double()),   description = s_optional(s_string()) # Can be string or null )  # 2. Build Structure product_structure <- build_structure(product_schema)  # 3. Parse JSON (description present) json_with_desc <- '{   \"product_id\": \"XYZ-123\",   \"details\": {\"name\": \"Gadget\", \"price\": 19.99},   \"description\": \"A useful gadget\" }' parsed1 <- parse_json(json_with_desc, product_structure) print(parsed1$description) # Output: [1] \"A useful gadget\"  # 4. Parse JSON (description is null) json_null_desc <- '{   \"product_id\": \"ABC-789\",   \"details\": {\"name\": \"Widget\", \"price\": 9.50},   \"description\": null }' parsed2 <- parse_json(json_null_desc, product_structure) print(parsed2$description) # Output: NULL"},{"path":"https://ixpantia.github.io/structr/index.html","id":"example-3-validation-error","dir":"","previous_headings":"Quick Start","what":"Example 3: Validation Error","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"# Using user_structure from Example 1  # Type mismatch: id should be integer, not string json_type_error <- '{ \"id\": \"123\", \"username\": \"badtype\", \"is_active\": true }' try(parse_json(json_type_error, user_structure)) # Output: Error: invalid type: string \"123\", expected an integer at line 1 column 13  # Missing field: is_active is required json_missing_field <- '{ \"id\": 456, \"username\": \"incomplete\" }' try(parse_json(json_missing_field, user_structure)) # Output: Error: missing field `is_active`"},{"path":"https://ixpantia.github.io/structr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Strictly Typed JSON Parsing and Validation","text":"MIT License. See LICENSE file.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Strictly Typed JSON Parsing and Validation","text":"Bug reports contributions welcome! Please submit issues pull requests GitHub.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"Strictly Typed JSON Parsing and Validation","text":"Andres Quintero andres@ixpantia.com","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalize and Validate a Structure Definition — build_structure","title":"Finalize and Validate a Structure Definition — build_structure","text":"Processes structure definition created using s_* helper functions (like s_integer(), s_map(), s_vector()) final, validated representation required parse_json() function.","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalize and Validate a Structure Definition — build_structure","text":"","code":"build_structure(x)"},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalize and Validate a Structure Definition — build_structure","text":"x structure definition created using s_* functions. defines expected schema JSON data (e.g., s_map(id = s_integer())).","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finalize and Validate a Structure Definition — build_structure","text":"object representing finalized structure definition. object specifically formatted use structure argument parse_json() function. internal details object typically needed user.","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finalize and Validate a Structure Definition — build_structure","text":"function serves two main purposes: Validation: checks user-provided structure definition correctness attempting parse JSON. includes verifying s_map() arguments correctly named use valid s_* definitions, s_vector() valid element_structure, nesting consistent. Errors definition (like duplicate field names s_map) caught stage. Preparation: converts user-friendly definition created s_* functions specific internal format required efficient JSON parsing engine used parse_json(). must call build_structure() schema definition passing parse_json().","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finalize and Validate a Structure Definition — build_structure","text":"","code":"# 1. Define the desired JSON structure using s_* functions my_schema_definition <- s_map(   product_id = s_string(),   quantity = s_integer(),   in_stock = s_logical(),   attributes = s_vector(s_string()) )  # 2. Finalize and validate the definition finalized_structure <- build_structure(my_schema_definition) # finalized_structure is now ready to be used with parse_json()  # Example with nested structures complex_definition <- s_map(   order_id = s_integer(),   customer = s_map(     name = s_string(),     email = s_string()   ),   items = s_vector(     s_map(       sku = s_string(),       price = s_double()     )   ) )  validated_complex_structure <- build_structure(complex_definition)  # Use the built structure with parse_json (see ?parse_json examples) json_data <- '{   \"product_id\": \"XYZ-123\",   \"quantity\": 5,   \"in_stock\": true,   \"attributes\": [\"red\", \"large\"] }' parsed_data <- parse_json(json_data, structure = finalized_structure) print(parsed_data) #> $product_id #> [1] \"XYZ-123\" #>  #> $quantity #> [1] 5 #>  #> $in_stock #> [1] TRUE #>  #> $attributes #> [1] \"red\"   \"large\" #>"},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse and Validate JSON Against a Structure — parse_json","title":"Parse and Validate JSON Against a Structure — parse_json","text":"Parses JSON string validates schema created build_structure(). Returns R object reflecting JSON content valid, throws detailed error.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse and Validate JSON Against a Structure — parse_json","text":"","code":"parse_json(json_string, structure)"},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse and Validate JSON Against a Structure — parse_json","text":"json_string character string containing JSON input. structure structure definition created build_structure(), based s_* functions.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse and Validate JSON Against a Structure — parse_json","text":"parsed validated data R object: JSON objects → named lists JSON arrays → unnamed lists Strings, numbers, booleans → scalar R values (character, numeric, integer, logical) Errors raised invalid syntax, type mismatches, missing extra fields, duplicate keys, integer overflows.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse and Validate JSON Against a Structure — parse_json","text":"Validation checks include: Types: JSON values must match declared structure (e.g., string vs integer). Required fields: fields s_map() must present. extra fields: Additional fields structure cause errors (unless .ignore_extra_fields = TRUE). Duplicate keys: Disallowed. Integer range: Must fit within R's 32-bit integer limits s_integer(). Homogeneous arrays: Elements s_vector() must match defined structure. Parsing powered serde_json Rust performance.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse and Validate JSON Against a Structure — parse_json","text":"","code":"# Define and build a structure schema <- build_structure(s_map(   id = s_integer(),   username = s_string(),   is_active = s_logical(),   scores = s_vector(s_double()) ))  # Valid input json <- '{\"id\":1,\"username\":\"user\",\"is_active\":true,\"scores\":[9.5,8.0]}' parse_json(json, schema) #> $id #> [1] 1 #>  #> $username #> [1] \"user\" #>  #> $is_active #> [1] TRUE #>  #> $scores #> [1] 9.5 8.0 #>   # Common errors: # - Invalid JSON # - Wrong type (e.g., \"id\": \"abc\") # - Missing fields # - Unexpected extra fields # - Integer overflow # - Duplicate keys"},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a Date Structure — s_date","title":"Define a Date Structure — s_date","text":"Creates intermediate definition JSON date. typically used within s_map() define fields contain date values.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a Date Structure — s_date","text":"","code":"s_date(format = \"%Y-%m-%d\")"},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a Date Structure — s_date","text":"format date format string. single string specifies expected format date JSON data. format compatible strftime function R. example, \"%Y-%m-%d\" \"2023-10-01\".","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a Date Structure — s_date","text":"intermediate list representing date structure definition.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a Map (Object) Structure — s_map","title":"Define a Map (Object) Structure — s_map","text":"Creates structure definition JSON object named fields. field must defined using s_* function (e.g., s_string(), s_integer(), nested structures).","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a Map (Object) Structure — s_map","text":"","code":"s_map(..., .ignore_extra_fields = FALSE)"},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a Map (Object) Structure — s_map","text":"... Named field definitions. name corresponds key JSON object, value must structure created s_* function. Call s_map() arguments define empty object. .ignore_extra_fields Logical (default FALSE). TRUE, allows extra fields input JSON ignored instead triggering validation error.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a Map (Object) Structure — s_map","text":"intermediate structure definition used build_structure().","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a Map (Object) Structure — s_map","text":"","code":"# Simple object s_map(name = s_string(), age = s_integer()) #> $type #> [1] \"map\" #>  #> $value #> $value$name #> $value$name$type #> [1] \"string\" #>  #>  #> $value$age #> $value$age$type #> [1] \"integer\" #>  #>  #>  #> $ignore_extra_fields #> [1] FALSE #>   # Nested structure s_map(   user = s_string(),   details = s_map(email = s_string(), active = s_logical()),   tags = s_vector(s_string()) ) #> $type #> [1] \"map\" #>  #> $value #> $value$user #> $value$user$type #> [1] \"string\" #>  #>  #> $value$details #> $value$details$type #> [1] \"map\" #>  #> $value$details$value #> $value$details$value$email #> $value$details$value$email$type #> [1] \"string\" #>  #>  #> $value$details$value$active #> $value$details$value$active$type #> [1] \"logical\" #>  #>  #>  #> $value$details$ignore_extra_fields #> [1] FALSE #>  #>  #> $value$tags #> $value$tags$type #> [1] \"vector\" #>  #> $value$tags$value #> $value$tags$value$type #> [1] \"string\" #>  #>  #>  #>  #> $ignore_extra_fields #> [1] FALSE #>   # Ignore extra JSON fields s_map(id = s_integer(), .ignore_extra_fields = TRUE) #> $type #> [1] \"map\" #>  #> $value #> $value$id #> $value$id$type #> [1] \"integer\" #>  #>  #>  #> $ignore_extra_fields #> [1] TRUE #>"},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":null,"dir":"Reference","previous_headings":"","what":"Define an Optional (Nullable) Structure — s_optional","title":"Define an Optional (Nullable) Structure — s_optional","text":"Creates intermediate definition indicating JSON value can either conform specified structure_definition JSON null. typically used within s_map() define fields required non-null value.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an Optional (Nullable) Structure — s_optional","text":"","code":"s_optional(structure_definition)"},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an Optional (Nullable) Structure — s_optional","text":"structure_definition structure definition JSON value conform null. result another s_* function call (e.g., s_integer(), s_string(), s_map(...)).","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define an Optional (Nullable) Structure — s_optional","text":"intermediate list representing optional structure definition.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define an Optional (Nullable) Structure — s_optional","text":"","code":"# Define a map where 'description' is optional (can be string or null) map_with_optional <- s_map(   id = s_integer(),   description = s_optional(s_string()) ) built_optional <- build_structure(map_with_optional) str(built_optional) #> Class 'Structure' <externalptr>  # Expected (simplified): # list(type = \"map\", #      value = list(id = list(type = \"integer\"), #                   description = list(type = \"optional\", #                                      value = list(type = \"string\"))), #      ...)  # Define a vector where elements can be integers or null vec_optional_elements <- s_vector(s_optional(s_integer())) build_structure(vec_optional_elements) #> Vector( #>     Optional( #>         Integer, #>     ), #> ) # Expected (simplified): # list(type = \"vector\", #      value = list(type = \"optional\", value = list(type = \"integer\")))  # --- Parsing Examples (see ?parse_json) ---  # Field present and valid json_present <- '{\"id\": 1, \"description\": \"A product\"}' parse_json(json_present, built_optional) #> $id #> [1] 1 #>  #> $description #> [1] \"A product\" #>  # Output: list(id = 1L, description = \"A product\")  # Optional field is null json_null <- '{\"id\": 2, \"description\": null}' parse_json(json_null, built_optional) #> $id #> [1] 2 #>  #> $description #> NULL #>  # Output: list(id = 2L, description = NULL)  # Optional field is missing (this causes an error by default with maps) # Note: Optionality here means \"can be null\", not \"can be absent\". # The 'missing field' error takes precedence unless the field is truly absent # from the structure definition itself (which isn't the case here). json_missing <- '{\"id\": 3}' try(parse_json(json_missing, built_optional)) #> $id #> [1] 3 #>  # Expected: Error about missing field \"description\"  # Parsing a vector with optional elements json_vec_opt <- '[10, null, 30, null]' parse_json(json_vec_opt, build_structure(vec_optional_elements)) #> [1] 10 NA 30 NA # Output: list(10L, NULL, 30L, NULL)"},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a Vector (Array) Structure — s_vector","title":"Define a Vector (Array) Structure — s_vector","text":"Creates intermediate definition JSON array elements must conform specified element_structure. definition used within s_map() finalized build_structure().","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a Vector (Array) Structure — s_vector","text":"","code":"s_vector(element_structure)"},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a Vector (Array) Structure — s_vector","text":"element_structure structure definition elements within vector. result another s_* function call (e.g., s_integer(), s_map(id = s_integer())).","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a Vector (Array) Structure — s_vector","text":"intermediate list representing vector structure definition.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a Vector (Array) Structure — s_vector","text":"","code":"# Define a vector of strings vec_str_def <- s_vector(s_string()) build_structure(vec_str_def) #> Vector( #>     String, #> ) # Expected: list(type = \"vector\", value = list(type = \"string\"))  # Define a vector of objects, each having an 'id' (integer) and 'name' (string) vec_obj_def <- s_vector(   s_map(id = s_integer(), name = s_string()) ) build_structure(vec_obj_def) #> Vector( #>     Map { #>         fields: { #>             \"name\": String, #>             \"id\": Integer, #>         }, #>         ignore_extra_fields: false, #>         expected_fields_str: [ #>             \"name\", #>             \"id\", #>         ], #>     }, #> ) # Expected: list(type = \"vector\", value = list(type = \"map\", #                   value = list(id = list(type = \"integer\"), #                                name = list(type = \"string\"))))  # Parsing example (see ?parse_json) json_data <- '[{\"id\": 1, \"name\": \"A\"}, {\"id\": 2, \"name\": \"B\"}]' parsed <- parse_json(json_data, build_structure(vec_obj_def)) print(parsed) # Will be a list of lists #> [[1]] #> [[1]]$id #> [1] 1 #>  #> [[1]]$name #> [1] \"A\" #>  #>  #> [[2]] #> [[2]]$id #> [1] 2 #>  #> [[2]]$name #> [1] \"B\" #>  #>"},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":null,"dir":"Reference","previous_headings":"","what":"Define Atomic Structure Types — structure_atomics","title":"Define Atomic Structure Types — structure_atomics","text":"functions create intermediate definitions basic JSON atomic types (integer, number/double, string, boolean). definitions used within s_vector() s_map() finalized build_structure().","code":""},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define Atomic Structure Types — structure_atomics","text":"","code":"s_integer()  s_double()  s_string()  s_logical()"},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define Atomic Structure Types — structure_atomics","text":"intermediate list representing atomic type definition (e.g., list(type = \"integer\")).","code":""},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define Atomic Structure Types — structure_atomics","text":"s_integer(): Expects JSON integer fits within R's 32-bit signed integer range. Allows JSON numbers without fractional parts (e.g., 123.0). s_double(): Expects JSON number (integer float). s_string(): Expects JSON string. s_logical(): Expects JSON boolean (true false).","code":""},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define Atomic Structure Types — structure_atomics","text":"","code":"build_structure(s_integer()) # list(type = \"integer\") #> Integer build_structure(s_double())  # list(type = \"double\") #> Double build_structure(s_string())  # list(type = \"string\") #> String build_structure(s_logical()) # list(type = \"logical\") #> Logical"}]
