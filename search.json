[{"path":"https://ixpantia.github.io/structr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 structr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"JSON Parsing Performance Benchmark","text":"document benchmarks performance different R packages parsing JSON strings R objects. compare: structr: Parses JSON simultaneously validates predefined schema (implemented Rust using serde simd-json). jsonlite: widely used, robust JSON parser (implemented C). rjson: Another JSON parser (implemented C). RJSONIO: versatile JSON parser, often used interfacing web APIs (implemented C). RcppSimdJson: high-performance JSON parser based simdjson, known speed efficiency (implemented C++). goal compare parsing speed across wider range JSON structures, simple atomic values large arrays deeply nested objects.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"benchmark-setup","dir":"Articles","previous_headings":"","what":"Benchmark Setup","title":"JSON Parsing Performance Benchmark","text":"test several scenarios representing common challenging JSON structures. structr, pre-build required structure definitions outside timed benchmark loop, reflecting typical usage (define structure , parse many times).","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"disclaimer","dir":"Articles","previous_headings":"Benchmark Setup","what":"Disclaimer","title":"JSON Parsing Performance Benchmark","text":"reading vignette GitHub Pages, benchmarks ran GitHub Actions. results differ every time run depending many factors. want true realistic benchmark, run code environment.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"json-data-and-structr-schemas","dir":"Articles","previous_headings":"Benchmark Setup","what":"JSON Data and structr Schemas","title":"JSON Parsing Performance Benchmark","text":"schemas JSON objects defined source code document. Since values can long, hidden final output, however, fully available source code.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"benchmarking-parameters","dir":"Articles","previous_headings":"Benchmark Setup","what":"Benchmarking Parameters","title":"JSON Parsing Performance Benchmark","text":"","code":"# Number of times to run each benchmark expression # Adjust down for slower scenarios if needed benchmark_times_fast <- 1000 benchmark_times_medium <- 500 benchmark_times_slow <- 100  # Unit for reporting timings benchmark_unit_fast <- \"us\" # microseconds benchmark_unit_medium <- \"ms\" # milliseconds benchmark_unit_slow <- \"ms\" # milliseconds"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"benchmark-results","dir":"Articles","previous_headings":"","what":"Benchmark Results","title":"JSON Parsing Performance Benchmark","text":"now run benchmarks scenario. plots show distribution execution times (lower better). Note Y-axis often logarithmic scale due potentially large performance differences. use check = \"equal\" wrap fromJSON calls try() complex cases strict equality might fail due floating point differences minor structural variations parsers, focusing instead raw speed.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-1-simple-flat-object","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 1: Simple Flat Object","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_simple_object <- microbenchmark(   structr = structr::parse_json(json_simple_object, structr_simple_object),   jsonlite = jsonlite::fromJSON(json_simple_object, simplifyDataFrame = FALSE),   rjson = rjson::fromJSON(json_simple_object),   RJSONIO = RJSONIO::fromJSON(json_simple_object, simplify = FALSE),   RcppSimdJson = RcppSimdJson::fparse(json_simple_object),   times = benchmark_times_fast, unit = benchmark_unit_fast, check = \"equal\" ) print_and_plot(bm_simple_object,   title = \"Scenario 1: Simple Flat Object Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq      mean  median      uq      max neval ##       structr  4.679  7.2290  9.185406  9.3575 10.6000   34.485  1000 ##      jsonlite 41.588 49.8030 59.042044 53.5800 62.6970 2606.850  1000 ##         rjson 27.562 36.3830 42.243946 40.9815 45.7250  106.017  1000 ##       RJSONIO 33.673 43.2605 48.998554 47.7945 53.3245  122.889  1000 ##  RcppSimdJson 21.029 27.5565 32.078184 30.9330 34.8400   65.302  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-2-simple-array-integers-50-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 2: Simple Array (Integers, 50 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_simple_array_int <- microbenchmark(   structr = structr::parse_json(json_simple_array_int, structr_simple_array_int),   jsonlite = jsonlite::fromJSON(json_simple_array_int), # simplify = TRUE default good here   rjson = rjson::fromJSON(json_simple_array_int),   RJSONIO = RJSONIO::fromJSON(json_simple_array_int), # simplify = TRUE default good here   RcppSimdJson = RcppSimdJson::fparse(json_simple_array_int),   times = benchmark_times_fast, unit = benchmark_unit_fast, check = \"equal\" )  print_and_plot(bm_simple_array_int,   title = \"Scenario 2: Simple Array (Integers) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min     lq      mean  median      uq      max neval ##       structr  3.707  6.071  7.674124  7.9100  8.8265   35.096  1000 ##      jsonlite 32.641 37.976 42.110548 41.3220 43.9120   97.963  1000 ##         rjson 31.549 37.916 43.239847 43.1205 45.8855  118.150  1000 ##       RJSONIO 44.954 52.919 58.109580 56.7960 60.1620  135.032  1000 ##  RcppSimdJson 21.169 26.239 33.150433 30.0810 32.3255 3014.310  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-3-simple-array-strings-26-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 3: Simple Array (Strings, 26 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_simple_array_str <- microbenchmark(   structr = structr::parse_json(json_simple_array_str, structr_simple_array_str),   jsonlite = jsonlite::fromJSON(json_simple_array_str),   rjson = rjson::fromJSON(json_simple_array_str),   RJSONIO = RJSONIO::fromJSON(json_simple_array_str),   RcppSimdJson = RcppSimdJson::fparse(json_simple_array_str),   times = benchmark_times_fast, unit = benchmark_unit_fast, check = \"equal\" )  print_and_plot(bm_simple_array_str,   title = \"Scenario 3: Simple Array (Strings) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq      mean  median      uq      max neval ##       structr  4.328  6.2165  7.601076  7.8945  8.7765   29.926  1000 ##      jsonlite 25.588 30.2915 33.678626 33.8585 35.7920   73.176  1000 ##         rjson 29.405 35.6165 39.996179 40.2200 42.7495  100.908  1000 ##       RJSONIO 40.707 47.8640 52.298756 51.9970 54.9780  138.007  1000 ##  RcppSimdJson 21.691 26.4790 32.942518 30.0110 32.0850 3141.467  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-4-nested-object","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 4: Nested Object","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_nested_object <-   microbenchmark(     structr = structr::parse_json(json_nested_object, structr_nested_object),     jsonlite = jsonlite::fromJSON(json_nested_object, simplifyVector = FALSE),     rjson = rjson::fromJSON(json_nested_object),     RJSONIO = RJSONIO::fromJSON(json_nested_object, simplify = FALSE), # avoid matrix/df conversion     RcppSimdJson = RcppSimdJson::fparse(json_nested_object),     times = benchmark_times_fast, unit = benchmark_unit_fast, check = NULL # Disable check due to potential minor diffs   )  print_and_plot(bm_nested_object,   title = \"Scenario 4: Nested Object Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq     mean  median      uq      max neval ##       structr 18.054 23.0430 26.31756 26.4145 28.5035   77.124  1000 ##      jsonlite 26.630 33.4530 40.79344 37.5300 40.5410 2924.223  1000 ##         rjson 40.244 51.0155 56.80037 56.9410 60.6375  123.581  1000 ##       RJSONIO 55.374 64.9860 72.06123 70.4760 74.9750  194.210  1000 ##  RcppSimdJson 29.315 37.1600 42.98127 43.3760 46.4865  134.621  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-5-array-of-simple-objects-100-objects","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 5: Array of Simple Objects (100 Objects)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_array_of_objects <-   microbenchmark(     structr = structr::parse_json(json_array_of_objects, structr_array_of_objects),     jsonlite = jsonlite::fromJSON(json_array_of_objects, simplifyVector = FALSE, simplifyDataFrame = FALSE), # Force list output     rjson = rjson::fromJSON(json_array_of_objects),     RJSONIO = RJSONIO::fromJSON(json_array_of_objects, simplify = FALSE), # Results in list of lists     RcppSimdJson = RcppSimdJson::fparse(json_array_of_objects),     times = benchmark_times_medium, unit = benchmark_unit_medium, check = NULL   ) print_and_plot(bm_array_of_objects,   title = \"Scenario 5: Array of 100 Objects Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq       mean    median       uq      max neval ##       structr 0.173413 0.2076675 0.22660718 0.2195090 0.235750 1.669873   500 ##      jsonlite 0.121907 0.1530400 0.17192715 0.1610405 0.168169 3.612646   500 ##         rjson 0.163805 0.1789845 0.19622029 0.1929700 0.209130 0.341417   500 ##       RJSONIO 0.250788 0.2683605 0.28117067 0.2772170 0.288478 0.470077   500 ##  RcppSimdJson 0.055343 0.0673505 0.08241493 0.0777200 0.096109 0.139921   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-6-large-array-of-simple-objects-1000-objects","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 6: Large Array of Simple Objects (1000 Objects)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_large_array_of_objects <-   microbenchmark(     structr = structr::parse_json(json_large_array_of_objects, structr_large_array_of_objects),     jsonlite = jsonlite::fromJSON(json_large_array_of_objects, simplifyVector = FALSE, simplifyDataFrame = FALSE),     rjson = rjson::fromJSON(json_large_array_of_objects),     RJSONIO = RJSONIO::fromJSON(json_large_array_of_objects, simplify = FALSE),     RcppSimdJson = RcppSimdJson::fparse(json_large_array_of_objects),     times = benchmark_times_medium,     unit = benchmark_unit_medium,     check = NULL # Disable check   )  print_and_plot(bm_large_array_of_objects,   title = \"Scenario 6: Array of 1000 Objects Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min       lq      mean    median       uq       max neval ##       structr 2.016449 2.221427 2.4370929 2.3297390 2.450343 13.778721   500 ##      jsonlite 1.248498 1.429290 1.5153915 1.4536855 1.533209  6.514076   500 ##         rjson 1.360336 1.399169 1.5595313 1.4290490 1.546374  6.906707   500 ##       RJSONIO 2.000790 2.164515 2.2761202 2.1868370 2.257129  7.819921   500 ##  RcppSimdJson 0.336408 0.357256 0.4256722 0.3737065 0.401889  5.326161   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-7-large-integer-array-10000-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 7: Large Integer Array (10,000 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_large_array_int <-   microbenchmark(     structr = structr::parse_json(json_large_array_int, structr_large_array_int),     jsonlite = jsonlite::fromJSON(json_large_array_int),     rjson = rjson::fromJSON(json_large_array_int),     RJSONIO = RJSONIO::fromJSON(json_large_array_int),     RcppSimdJson = RcppSimdJson::fparse(json_large_array_int),     times = benchmark_times_medium,     unit = benchmark_unit_medium,     check = \"equal\"   ) print_and_plot(bm_large_array_int,   title = \"Scenario 7: Large Integer Array (10k) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq      mean   median        uq       max neval ##       structr 0.186288 0.1946125 0.2088062 0.200719 0.2226700  0.339684   500 ##      jsonlite 2.258431 2.6164440 2.7717924 2.691222 2.7941350  7.318526   500 ##         rjson 1.045199 1.0655670 1.1548414 1.079763 1.1064025 10.940729   500 ##       RJSONIO 2.527622 2.5627985 2.6744144 2.579905 2.6039900  7.647779   500 ##  RcppSimdJson 0.189503 0.2040210 0.2213945 0.212947 0.2388355  0.402901   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-8-large-string-array-10000-items","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 8: Large String Array (10,000 items)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_large_array_str <-   microbenchmark(     structr = structr::parse_json(json_large_array_str, structr_large_array_str),     jsonlite = jsonlite::fromJSON(json_large_array_str),     rjson = rjson::fromJSON(json_large_array_str),     RJSONIO = RJSONIO::fromJSON(json_large_array_str),     RcppSimdJson = RcppSimdJson::fparse(json_large_array_str),     times = benchmark_times_medium,     unit = benchmark_unit_medium,     check = \"equal\"   ) print_and_plot(bm_large_array_str,   title = \"Scenario 8: Large String Array (10k) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min       lq      mean    median        uq      max neval ##       structr 0.677062 0.695477 0.7119222 0.7049245 0.7281375 0.824798   500 ##      jsonlite 2.290651 2.412458 2.6244086 2.4767530 2.6679495 6.953295   500 ##         rjson 1.308570 1.340549 1.4379887 1.3633075 1.3907930 5.912314   500 ##       RJSONIO 3.412302 3.475731 3.5420232 3.4969705 3.5244710 8.321816   500 ##  RcppSimdJson 0.639252 0.659640 0.6993047 0.6725395 0.7046035 9.117971   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-9-deeply-nested-object-10-levels","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 9: Deeply Nested Object (10 levels)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_deep_nest <- microbenchmark(   structr = structr::parse_json(json_deep_nest, structr_deep_nest),   jsonlite = jsonlite::fromJSON(json_deep_nest, simplifyVector = FALSE, simplifyDataFrame = FALSE),   rjson = rjson::fromJSON(json_deep_nest),   RJSONIO = RJSONIO::fromJSON(json_deep_nest, simplify = FALSE),   RcppSimdJson = RcppSimdJson::fparse(json_deep_nest),   times = benchmark_times_fast,   unit = benchmark_unit_fast,   check = \"equal\" ) print_and_plot(bm_deep_nest,   title = \"Scenario 9: Deeply Nested Object (10 Levels) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_fast, \", log scale)\") ) ## Unit: microseconds ##          expr    min      lq      mean  median      uq       max neval ##       structr 12.423 15.7295  17.96122 17.8430 19.2010    46.707  1000 ##      jsonlite 16.381 20.1880  23.25646 23.0230 24.5660    72.986  1000 ##         rjson 28.813 35.8415  41.50652 40.7060 43.4960   115.486  1000 ##       RJSONIO 37.069 45.2945 136.21307 49.5925 52.8340 85317.526  1000 ##  RcppSimdJson 23.555 28.5130  32.85223 32.2505 34.4545    78.587  1000"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"scenario-10-wide-object-100-fields","dir":"Articles","previous_headings":"Benchmark Results","what":"Scenario 10: Wide Object (100 fields)","title":"JSON Parsing Performance Benchmark","text":"","code":"bm_wide_object <- microbenchmark(   structr = structr::parse_json(json_wide_object, structr_wide_object),   jsonlite = jsonlite::fromJSON(json_wide_object, simplifyVector = FALSE, simplifyDataFrame = FALSE),   rjson = rjson::fromJSON(json_wide_object),   RJSONIO = RJSONIO::fromJSON(json_wide_object, simplify = FALSE),   RcppSimdJson = RcppSimdJson::fparse(json_wide_object),   times = benchmark_times_medium,   unit = benchmark_unit_medium,   check = \"equal\" ) print_and_plot(bm_wide_object,   title = \"Scenario 10: Wide Object (100 Fields) Parsing Time\",   y_label = paste(\"Time (\", benchmark_unit_medium, \", log scale)\") ) ## Unit: milliseconds ##          expr      min        lq       mean    median        uq      max neval ##       structr 0.058189 0.0671550 0.07134398 0.0708920 0.0737080 0.117599   500 ##      jsonlite 0.039213 0.0490120 0.05298353 0.0527790 0.0556085 0.103663   500 ##         rjson 0.063178 0.0720940 0.08740031 0.0776250 0.0820630 4.735289   500 ##       RJSONIO 0.079338 0.0894765 0.09700844 0.0962500 0.1019650 0.171229   500 ##  RcppSimdJson 0.033293 0.0410720 0.04667174 0.0464265 0.0506945 0.101420   500"},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"summary-across-scenarios","dir":"Articles","previous_headings":"","what":"Summary Across Scenarios","title":"JSON Parsing Performance Benchmark","text":"Let’s combine median times scenarios visualize relative performance. convert times microseconds (us) comparison.","code":""},{"path":"https://ixpantia.github.io/structr/articles/bench.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"JSON Parsing Performance Benchmark","text":"structr competes well every JSON parsing library added benefit schema validation parsing.","code":""},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with structr","text":"ever trouble data-type consistency interacting external systems like web API database? uncommon JSON parsers R fail parse serialize data specification external system. example, let’s say API requires field JSON object single scalar integer value. However, get constant 400 Bad Request packages like jsonlite serialize integer vector length 1. API requires nested structure unbox values becomes impractical. structr package provides solution problem allowing define structure data serialize deserialize JSON. (added benefit blazingly fast.)","code":""},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"defining-a-structure","dir":"Articles","previous_headings":"","what":"Defining a structure","title":"Getting Started with structr","text":"Defining structure structr involves combining different data-types build complex structures. combined s_* functions like ?s_map, ?s_vector, ?s_string others. desired structure reached compiled using ?build_structure function. compiled version used parse serialize structures want.","code":"structure_basic <- build_structure(   s_map(     x = s_integer(),     y = s_double(),     z = s_optional(s_string())   ) ) print(structure_basic) #> Map { #>     fields: { #>         \"z\": Optional( #>             String, #>         ), #>         \"x\": Integer, #>         \"y\": Double, #>     }, #>     ignore_extra_fields: false, #>     expected_fields_str: [ #>         \"z\", #>         \"x\", #>         \"y\", #>     ], #> }"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"parsing-json","dir":"Articles","previous_headings":"","what":"Parsing JSON","title":"Getting Started with structr","text":"can use structure like one defined parse JSON exactly specification. may noticed z combination ?s_optional ?s_string. structr non-null default. Every field required default, meaning NULL NA. try parse JSON without field x get error. However, try parse JSON missing optional field z, fail. s_optional means value associated key can null missing JSON object. get errors types incorrect. pass string x y get errors.","code":"json_str <- '{\"x\": 1, \"y\": 99.9, \"z\": \"value\"}'  parse_json(json_str, structure_basic) #> $x #> [1] 1 #>  #> $y #> [1] 99.9 #>  #> $z #> [1] \"value\" json_str <- '{\"y\": 99.9, \"z\": \"value\"}' try(parse_json(json_str, structure_basic)) #> Error in parse_json(json_str, structure_basic) :  #>   Serde(\"missing field `x`\") at character 0  # Using 'null' for a non-optional field also causes an error json_str_null <- '{\"x\": null, \"y\": 99.9, \"z\": \"value\"}' try(parse_json(json_str_null, structure_basic)) #> Error in parse_json(json_str_null, structure_basic) :  #>   ExpectedSigned at character 0 json_str_missing_z <- '{\"x\": 1, \"y\": 99.9}' parse_json(json_str_missing_z, structure_basic) #> $x #> [1] 1 #>  #> $y #> [1] 99.9  json_str_null_z <- '{\"x\": 1, \"y\": 99.9, \"z\": null}' parse_json(json_str_null_z, structure_basic) #> $x #> [1] 1 #>  #> $y #> [1] 99.9 #>  #> $z #> NULL json_str_bad_types <- '{\"x\": \"1\", \"y\": \"99.9\", \"z\": \"value\"}' try(parse_json(json_str_bad_types, structure_basic)) #> Error in parse_json(json_str_bad_types, structure_basic) :  #>   ExpectedSigned at character 0"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"serializing-json","dir":"Articles","previous_headings":"","what":"Serializing JSON","title":"Getting Started with structr","text":"can use structure convert R objects corresponding JSON. serialize_json ensures R object conforms structure creating JSON string. R object doesn’t match structure (e.g., wrong type, missing required field), serialize_json raise error.","code":"r_list <- list(x = 1L, y = 99.9, z = \"value\") serialize_json(r_list, structure_basic) #> {\"z\":\"value\",\"x\":1,\"y\":99.9}  r_list_null_z <- list(x = 2L, y = 100.1) serialize_json(r_list_null_z, structure_basic) #> {\"z\":null,\"x\":2,\"y\":100.1} # Wrong type for 'x' r_list_bad_type <- list(x = \"1\", y = 99.9, z = \"value\") try(serialize_json(r_list_bad_type, structure_basic)) #> Error in serialize_json(r_list_bad_type, structure_basic) :  #>   Failed to serialize structure: Serde(\"Type mismatch: expected an integer\") at character 0  # Missing required field 'y' r_list_missing_field <- list(x = 1L, z = \"value\") try(serialize_json(r_list_missing_field, structure_basic)) #> Error in serialize_json(r_list_missing_field, structure_basic) :  #>   Failed to serialize structure: Serde(\"Found NA/null values in non-optional field of type a floating-point number\") at character 0  # Providing NA for a non-optional field 'y' r_list_na_field <- list(x = 1L, y = NA_real_, z = \"value\") try(serialize_json(r_list_na_field, structure_basic)) #> Error in serialize_json(r_list_na_field, structure_basic) :  #>   Failed to serialize structure: Serde(\"Found NA/null values in non-optional field of type a floating-point number\") at character 0"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"more-complex-structures-parsing","dir":"Articles","previous_headings":"","what":"More Complex Structures (Parsing)","title":"Getting Started with structr","text":"Real-world JSON, especially APIs, often involves nested objects, arrays objects, optional fields, specific data types like dates. structr designed handle complexities robustly parsing. Let’s imagine ’re interacting e-commerce API returns order details. typical JSON response might look like : can define structr schema strictly match structure: Now, let’s define JSON string R parse using compiled structure. Let’s try another example optional fields (email notes) null: incoming JSON deviates structure (e.g., wrong type quantity, missing status, unexpected extra field, incorrect date format), parse_json raise specific error, ensuring data integrity working external systems. example demonstrates s_map, s_vector, s_optional, s_date, atomic types (s_string, s_integer, s_double) can combined model validate complex, real-world JSON data parsing.","code":"{   \"order_id\": \"ORD-12345\",   \"order_date\": \"2024-07-29\",   \"status\": \"processing\",   \"customer\": {     \"customer_id\": 987,     \"name\": \"Jane Doe\",     \"email\": \"jane.doe@example.com\"   },   \"items\": [     {       \"sku\": \"ITEM001\",       \"product_name\": \"Wireless Mouse\",       \"quantity\": 1,       \"unit_price\": 25.99     },     {       \"sku\": \"ITEM002\",       \"product_name\": \"Keyboard\",       \"quantity\": 1,       \"unit_price\": 75.50     }   ],   \"shipping_address\": {     \"street\": \"123 Example St\",     \"city\": \"Metropolis\",     \"zip_code\": \"10001\",     \"country\": \"USA\"   },   \"notes\": \"Gift wrap requested.\" } # Define the schema for a single order item item_schema_parse <- s_map(   sku = s_string(),   product_name = s_string(),   quantity = s_integer(),   unit_price = s_double() )  # Define the schema for the customer customer_schema_parse <- s_map(   customer_id = s_integer(),   name = s_string(),   email = s_optional(s_string()) # Email might be null )  # Define the schema for the shipping address address_schema_parse <- s_map(   street = s_string(),   city = s_string(),   zip_code = s_string(),   country = s_string() )  # Combine into the main order schema order_schema_parse <- s_map(   order_id = s_string(),   order_date = s_date(format = \"%Y-%m-%d\"), # Expecting specific date format   status = s_string(),   customer = customer_schema_parse,              # Nest the customer schema   items = s_vector(item_schema_parse),           # Expect a vector of items matching item_schema   shipping_address = address_schema_parse,       # Nest the address schema   notes = s_optional(s_string())           # Notes might be null )  # Build the final structure compiled_order_structure_parse <- build_structure(order_schema_parse)  # Print the structure (optional, for inspection) # print(compiled_order_structure_parse) json_order_1 <- '{   \"order_id\": \"ORD-12345\",   \"order_date\": \"2024-07-29\",   \"status\": \"processing\",   \"customer\": {     \"customer_id\": 987,     \"name\": \"Jane Doe\",     \"email\": \"jane.doe@example.com\"   },   \"items\": [     {       \"sku\": \"ITEM001\",       \"product_name\": \"Wireless Mouse\",       \"quantity\": 1,       \"unit_price\": 25.99     },     {       \"sku\": \"ITEM002\",       \"product_name\": \"Keyboard\",       \"quantity\": 1,       \"unit_price\": 75.50     }   ],   \"shipping_address\": {     \"street\": \"123 Example St\",     \"city\": \"Metropolis\",     \"zip_code\": \"10001\",     \"country\": \"USA\"   },   \"notes\": \"Gift wrap requested.\" }'  # Parse the JSON string parsed_order_1 <- parse_json(json_order_1, compiled_order_structure_parse)  # Inspect the parsed R object structure and types str(parsed_order_1, max.level = 2) #> List of 7 #>  $ order_id        : chr \"ORD-12345\" #>  $ order_date      : Date[1:1], format: \"2024-07-29\" #>  $ status          : chr \"processing\" #>  $ customer        :List of 3 #>   ..$ customer_id: int 987 #>   ..$ name       : chr \"Jane Doe\" #>   ..$ email      : chr \"jane.doe@example.com\" #>  $ items           :List of 2 #>   ..$ :List of 4 #>   ..$ :List of 4 #>  $ shipping_address:List of 4 #>   ..$ street  : chr \"123 Example St\" #>   ..$ city    : chr \"Metropolis\" #>   ..$ zip_code: chr \"10001\" #>   ..$ country : chr \"USA\" #>  $ notes           : chr \"Gift wrap requested.\"  # Access specific parts print(paste(\"Order Status:\", parsed_order_1$status)) #> [1] \"Order Status: processing\" print(paste(\"Number of items:\", length(parsed_order_1$items))) #> [1] \"Number of items: 2\" print(paste(\"First item SKU:\", parsed_order_1$items[[1]]$sku)) #> [1] \"First item SKU: ITEM001\" # Notice the order_date is now an R Date object print(paste(\"Order Date:\", parsed_order_1$order_date)) #> [1] \"Order Date: 2024-07-29\" class(parsed_order_1$order_date) #> [1] \"Date\" json_order_2 <- '{   \"order_id\": \"ORD-67890\",   \"order_date\": \"2024-07-30\",   \"status\": \"shipped\",   \"customer\": {     \"customer_id\": 654,     \"name\": \"John Smith\",     \"email\": null   },   \"items\": [     {       \"sku\": \"ITEM003\",       \"product_name\": \"USB Hub\",       \"quantity\": 2,       \"unit_price\": 12.00     }   ],   \"shipping_address\": {     \"street\": \"456 Test Ave\",     \"city\": \"Gotham\",     \"zip_code\": \"20002\",     \"country\": \"USA\"   },   \"notes\": null }'  # Parse the second JSON parsed_order_2 <- parse_json(json_order_2, compiled_order_structure_parse)  # Check the optional fields (which are NULL in R) print(paste(\"Customer Email:\", parsed_order_2$customer$email)) #> [1] \"Customer Email: \" is.null(parsed_order_2$customer$email) #> [1] TRUE print(paste(\"Order Notes:\", parsed_order_2$notes)) #> [1] \"Order Notes: \" is.null(parsed_order_2$notes) #> [1] TRUE"},{"path":"https://ixpantia.github.io/structr/articles/getting_started.html","id":"more-complex-structures-serialization","dir":"Articles","previous_headings":"","what":"More Complex Structures (Serialization)","title":"Getting Started with structr","text":"Just structr helps enforce structure parsing JSON, ’s equally valuable creating JSON send external systems, especially strict API requirements. ensures R data correctly formatted transmission. Let’s imagine need send event log data API. API particular format: expects specific fields: eventId, eventDate, eventType, userId, details. eventDate must YYYYMMDD format. userId must integer. details nested object containing source (string) metadata (optional map). metadata can contain key (string) value (double), optional within metadata map, metadata present, must object. can define structr schema meet strict requirements serialization: Now, let’s create R data want send API. ’s crucial R data types match schema (e.g., use .Date() eventDate, integer userId). Let’s serialize R lists using strict structure. serialize_json validate R list schema producing JSON. Now, let’s see happens R data doesn’t conform structure expected API schema. examples show serialize_json uses structr schema enforce type correctness structure generating JSON. critical reliable communication APIs demand specific formats, preventing malformed requests runtime errors server side. use s_date specific format ensures dates serialized exactly required.","code":"# Schema for the optional metadata map metadata_schema_serialize <- s_map(   key = s_optional(s_string()),   value = s_optional(s_double()) )  # Schema for the details object details_schema_serialize <- s_map(   source = s_string(),   metadata = s_optional(metadata_schema_serialize) # The whole metadata map is optional )  # Main schema for the log entry log_entry_schema_serialize <- s_map(   eventId = s_string(),   eventDate = s_date(format = \"%Y%m%d\"), # Strict date format required by API   eventType = s_string(),   userId = s_integer(),   details = details_schema_serialize      # Nest the details schema )  # Build the final structure for serialization compiled_log_entry_structure_serialize <- build_structure(log_entry_schema_serialize)  print(compiled_log_entry_structure_serialize) #> Map { #>     fields: { #>         \"userId\": Integer, #>         \"eventType\": String, #>         \"eventDate\": Date { #>             format: \"%Y%m%d\", #>         }, #>         \"eventId\": String, #>         \"details\": Map { #>             fields: { #>                 \"source\": String, #>                 \"metadata\": Optional( #>                     Map { #>                         fields: { #>                             \"value\": Optional( #>                                 Double, #>                             ), #>                             \"key\": Optional( #>                                 String, #>                             ), #>                         }, #>                         ignore_extra_fields: false, #>                         expected_fields_str: [ #>                             \"value\", #>                             \"key\", #>                         ], #>                     }, #>                 ), #>             }, #>             ignore_extra_fields: false, #>             expected_fields_str: [ #>                 \"source\", #>                 \"metadata\", #>             ], #>         }, #>     }, #>     ignore_extra_fields: false, #>     expected_fields_str: [ #>         \"userId\", #>         \"eventType\", #>         \"eventDate\", #>         \"eventId\", #>         \"details\", #>     ], #> } # Example 1: Log entry with full details including metadata log_entry_data_1 <- list(   eventId = \"evt-aaa-001\",   eventDate = as.Date(\"2024-08-15\"),   eventType = \"user_login\",   userId = 12345L,   details = list(     source = \"web_frontend\",     metadata = list(       key = \"session_duration\",       value = 350.5     )   ) )  # Example 2: Log entry where metadata is missing log_entry_data_2 <- list(   eventId = \"evt-bbb-002\",   eventDate = as.Date(\"2024-08-16\"),   eventType = \"page_view\",   userId = 98765L,   details = list(     source = \"mobile_app\"   ) )  # Example 3: Log entry where metadata is present, but its inner fields are NULL log_entry_data_3 <- list(   eventId = \"evt-ccc-003\",   eventDate = as.Date(\"2024-08-17\"),   eventType = \"item_click\",   userId = 12345L,   details = list(     source = \"web_frontend\",     metadata = list(       key = NULL,       value = NULL     )   ) )  str(log_entry_data_1) # Check R types #> List of 5 #>  $ eventId  : chr \"evt-aaa-001\" #>  $ eventDate: Date[1:1], format: \"2024-08-15\" #>  $ eventType: chr \"user_login\" #>  $ userId   : int 12345 #>  $ details  :List of 2 #>   ..$ source  : chr \"web_frontend\" #>   ..$ metadata:List of 2 #>   .. ..$ key  : chr \"session_duration\" #>   .. ..$ value: num 350 # Serialize Example 1 serialize_json(log_entry_data_1, compiled_log_entry_structure_serialize, pretty = TRUE) #> { #>   \"userId\": 12345, #>   \"eventType\": \"user_login\", #>   \"eventDate\": \"20240815\", #>   \"eventId\": \"evt-aaa-001\", #>   \"details\": { #>     \"source\": \"web_frontend\", #>     \"metadata\": { #>       \"value\": 350.5, #>       \"key\": \"session_duration\" #>     } #>   } #> }  # Serialize Example 2 serialize_json(log_entry_data_2, compiled_log_entry_structure_serialize, pretty = TRUE) #> { #>   \"userId\": 98765, #>   \"eventType\": \"page_view\", #>   \"eventDate\": \"20240816\", #>   \"eventId\": \"evt-bbb-002\", #>   \"details\": { #>     \"source\": \"mobile_app\", #>     \"metadata\": null #>   } #> }  # Serialize Example 3 serialize_json(log_entry_data_3, compiled_log_entry_structure_serialize, pretty = TRUE) #> { #>   \"userId\": 12345, #>   \"eventType\": \"item_click\", #>   \"eventDate\": \"20240817\", #>   \"eventId\": \"evt-ccc-003\", #>   \"details\": { #>     \"source\": \"web_frontend\", #>     \"metadata\": { #>       \"value\": null, #>       \"key\": null #>     } #>   } #> } # Error Case 1: Incorrect date type (character instead of Date) bad_data_date_type <- log_entry_data_1 bad_data_date_type$eventDate <- \"2024-08-15\" # Should be as.Date(\"2024-08-15\") try(serialize_json(bad_data_date_type, compiled_log_entry_structure_serialize)) #> Error in serialize_json(bad_data_date_type, compiled_log_entry_structure_serialize) :  #>   Failed to serialize structure: Serde(\"Type mismatch: expected a date\") at character 0  # Error Case 2: Incorrect type for userId (numeric instead of integer) bad_data_user_type <- log_entry_data_1 bad_data_user_type$userId <- 12345.0 # Should be 12345L try(serialize_json(bad_data_user_type, compiled_log_entry_structure_serialize)) #> Error in serialize_json(bad_data_user_type, compiled_log_entry_structure_serialize) :  #>   Failed to serialize structure: Serde(\"Type mismatch: expected an integer\") at character 0  # Error Case 3: Missing a required field ('eventType') in the R list bad_data_missing_field <- log_entry_data_1 bad_data_missing_field$eventType <- NULL # Remove the field try(serialize_json(bad_data_missing_field, compiled_log_entry_structure_serialize)) #> Error in serialize_json(bad_data_missing_field, compiled_log_entry_structure_serialize) :  #>   Failed to serialize structure: Serde(\"Found NA/null values in non-optional field of type a string\") at character 0  # Error Case 4: Providing NA for a required, non-optional field ('source') bad_data_na_field <- log_entry_data_1 bad_data_na_field$details$source <- NA_character_ try(serialize_json(bad_data_na_field, compiled_log_entry_structure_serialize)) #> Error in serialize_json(bad_data_na_field, compiled_log_entry_structure_serialize) :  #>   Failed to serialize structure: Serde(\"Found NA/null values in non-optional field of type a string\") at character 0"},{"path":"https://ixpantia.github.io/structr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"ixpantia, SRL. Copyright holder. Andres Quintero. Author, maintainer. authors dependency Rust crates. Contributor.           see inst/AUTHORS file details","code":""},{"path":"https://ixpantia.github.io/structr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Quintero (2025). structr: Strictly Typed JSON Parsing Validation. R package version 0.1.0.9000, https://github.com/ixpantia/structr.","code":"@Manual{,   title = {structr: Strictly Typed JSON Parsing and Validation},   author = {Andres Quintero},   year = {2025},   note = {R package version 0.1.0.9000},   url = {https://github.com/ixpantia/structr}, }"},{"path":[]},{"path":"https://ixpantia.github.io/structr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Strictly Typed JSON Parsing and Validation","text":"structr high-performance R package designed strict JSON parsing serialization schema validation. Whether ’re working APIs, databases, complex nested JSON, structr ensures data conforms exactly required structure—reading writing. Powered Rust (serde, simd_json) exposed R via {extendr}, provides significant speed advantages traditional R JSON tools offering precise control data structure types.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Strictly Typed JSON Parsing and Validation","text":"Schema Definition R: Use expressive R functions like s_map, s_vector, s_integer, s_double, s_string, s_logical, s_optional, s_date. Strict Validation: Catch type mismatches, missing fields, unexpected fields, NULLs clear error messages. High Performance: Combines validation parsing efficient data ingestion. Bidirectional Support: Parse JSON serialize R data back JSON, validating schema.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"planned-features","dir":"","previous_headings":"","what":"Planned Features","title":"Strictly Typed JSON Parsing and Validation","text":"Support enums complex/custom validations. Better date/time parsing formatting options. Clear, location-aware error messages help identify problems early.","code":""},{"path":[]},{"path":"https://ixpantia.github.io/structr/index.html","id":"prerequisites","dir":"","previous_headings":"Installation","what":"Prerequisites","title":"Strictly Typed JSON Parsing and Validation","text":"must Rust (rustc, cargo) installed. can install via rustup: Make sure Rust >= 1.70.","code":"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"},{"path":"https://ixpantia.github.io/structr/index.html","id":"install-from-github","dir":"","previous_headings":"Installation","what":"Install from GitHub","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"# Install 'remotes' if needed install.packages(\"remotes\") #> Installing package into '/tmp/RtmpbVVsxu/temp_libpath76b9a7e042934' #> (as 'lib' is unspecified) remotes::install_github(\"ixpantia/structr\") #> Downloading GitHub repo ixpantia/structr@HEAD #>  #> ── R CMD build ───────────────────────────────────────────────────────────────── #> * checking for file ‘/tmp/RtmpBHXbXI/remotes76ffe3b33d728/ixpantia-structr-cfe71fb/DESCRIPTION’ ... OK #> * preparing ‘structr’: #> * checking DESCRIPTION meta-information ... OK #> * cleaning src #> * checking for LF line-endings in source and make files and shell scripts #> * checking for empty or unneeded directories #> * building ‘structr_0.1.0.9000.tar.gz’ #> Installing package into '/tmp/RtmpbVVsxu/temp_libpath76b9a7e042934' #> (as 'lib' is unspecified)"},{"path":[]},{"path":"https://ixpantia.github.io/structr/index.html","id":"define-a-schema","dir":"","previous_headings":"Quick Start","what":"Define a Schema","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"library(structr)  schema <- s_map(   x = s_integer(),   y = s_double(),   z = s_optional(s_string()) )  compiled <- build_structure(schema)"},{"path":"https://ixpantia.github.io/structr/index.html","id":"parse-json","dir":"","previous_headings":"Quick Start","what":"Parse JSON","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"json <- '{\"x\": 1, \"y\": 99.9, \"z\": \"value\"}' parse_json(json, compiled) #> $x #> [1] 1 #>  #> $y #> [1] 99.9 #>  #> $z #> [1] \"value\""},{"path":"https://ixpantia.github.io/structr/index.html","id":"serialize-json","dir":"","previous_headings":"Quick Start","what":"Serialize JSON","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"r_data <- list(x = 1L, y = 99.9, z = \"value\") serialize_json(r_data, compiled, pretty = TRUE) #> { #>   \"y\": 99.9, #>   \"x\": 1, #>   \"z\": \"value\" #> }"},{"path":"https://ixpantia.github.io/structr/index.html","id":"error-handling","dir":"","previous_headings":"","what":"Error Handling","title":"Strictly Typed JSON Parsing and Validation","text":"Invalid input raises clear, structured errors:","code":"bad_data <- '{\"x\": \"not-an-int\", \"y\": 10.5, \"z\": \"ok\"}' try(parse_json(bad_data, compiled)) #> Error in parse_json(bad_data, compiled) : ExpectedSigned at character 0"},{"path":"https://ixpantia.github.io/structr/index.html","id":"handling-optional-and-missing-fields","dir":"","previous_headings":"","what":"Handling Optional and Missing Fields","title":"Strictly Typed JSON Parsing and Validation","text":"fields required default. Use s_optional() allow null missing values.","code":"parse_json('{\"x\": 1, \"y\": 99.9}', compiled) # OK #> $x #> [1] 1 #>  #> $y #> [1] 99.9 try(parse_json('{\"x\": null, \"y\": 99.9}', compiled)) # Error #> Error in parse_json(\"{\\\"x\\\": null, \\\"y\\\": 99.9}\", compiled) :  #>   ExpectedSigned at character 0"},{"path":"https://ixpantia.github.io/structr/index.html","id":"advanced-example-nested-and-complex-structures","dir":"","previous_headings":"","what":"Advanced Example: Nested and Complex Structures","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"order_schema <- s_map(   order_id = s_string(),   order_date = s_date(format = \"%Y-%m-%d\"),   customer = s_map(     customer_id = s_integer(),     name = s_string(),     email = s_optional(s_string())   ),   items = s_vector(s_map(     sku = s_string(),     product_name = s_string(),     quantity = s_integer(),     unit_price = s_double()   )),   shipping_address = s_map(     street = s_string(),     city = s_string(),     zip_code = s_string(),     country = s_string()   ),   notes = s_optional(s_string()) )  compiled_order <- build_structure(order_schema) # Parse or serialize safely order_json <- '{\"order_id\":\"ORD-1\",\"order_date\":\"2024-01-01\",\"customer\":{\"customer_id\":1,\"name\":\"Alice\"},\"items\":[],\"shipping_address\":{\"street\":\"1 Main\",\"city\":\"City\",\"zip_code\":\"00000\",\"country\":\"USA\"}}' parsed <- parse_json(order_json, compiled_order)  serialize_json(parsed, compiled_order, pretty = TRUE) #> { #>   \"shipping_address\": { #>     \"country\": \"USA\", #>     \"street\": \"1 Main\", #>     \"city\": \"City\", #>     \"zip_code\": \"00000\" #>   }, #>   \"order_id\": \"ORD-1\", #>   \"customer\": { #>     \"email\": null, #>     \"name\": \"Alice\", #>     \"customer_id\": 1 #>   }, #>   \"order_date\": \"2024-01-01\", #>   \"items\": [], #>   \"notes\": null #> }"},{"path":"https://ixpantia.github.io/structr/index.html","id":"strict-serialization-example","dir":"","previous_headings":"","what":"Strict Serialization Example","title":"Strictly Typed JSON Parsing and Validation","text":"","code":"log_schema <- s_map(   eventId = s_string(),   eventDate = s_date(\"%Y%m%d\"),   eventType = s_string(),   userId = s_integer(),   details = s_map(     source = s_string(),     metadata = s_optional(s_map(       key = s_optional(s_string()),       value = s_optional(s_double())     ))   ) )  compiled_log <- build_structure(log_schema)  r_log <- list(   eventId = \"evt-001\",   eventDate = as.Date(\"2024-08-01\"),   eventType = \"login\",   userId = 123L,   details = list(     source = \"web\",     metadata = list(key = \"duration\", value = 320.5)   ) )  serialize_json(r_log, compiled_log, pretty = TRUE) #> { #>   \"eventDate\": \"20240801\", #>   \"eventType\": \"login\", #>   \"details\": { #>     \"metadata\": { #>       \"value\": 320.5, #>       \"key\": \"duration\" #>     }, #>     \"source\": \"web\" #>   }, #>   \"eventId\": \"evt-001\", #>   \"userId\": 123 #> }"},{"path":"https://ixpantia.github.io/structr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Strictly Typed JSON Parsing and Validation","text":"MIT License. See LICENSE.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Strictly Typed JSON Parsing and Validation","text":"Please file issues submit PRs https://github.com/ixpantia/structr.","code":""},{"path":"https://ixpantia.github.io/structr/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"Strictly Typed JSON Parsing and Validation","text":"Andres Quintero andres@ixpantia.com","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalize and Validate a Structure Definition — build_structure","title":"Finalize and Validate a Structure Definition — build_structure","text":"Processes structure definition created using s_* helper functions (like s_integer(), s_map(), s_vector()) final, validated representation required parse_json() function.","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalize and Validate a Structure Definition — build_structure","text":"","code":"build_structure(x)"},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalize and Validate a Structure Definition — build_structure","text":"x structure definition created using s_* functions. defines expected schema JSON data (e.g., s_map(id = s_integer())).","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finalize and Validate a Structure Definition — build_structure","text":"object representing finalized structure definition. object specifically formatted use structure argument parse_json() function. internal details object typically needed user.","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finalize and Validate a Structure Definition — build_structure","text":"function serves two main purposes: Validation: checks user-provided structure definition correctness attempting parse JSON. includes verifying s_map() arguments correctly named use valid s_* definitions, s_vector() valid element_structure, nesting consistent. Errors definition (like duplicate field names s_map) caught stage. Preparation: converts user-friendly definition created s_* functions specific internal format required efficient JSON parsing engine used parse_json(). must call build_structure() schema definition passing parse_json().","code":""},{"path":"https://ixpantia.github.io/structr/reference/build_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finalize and Validate a Structure Definition — build_structure","text":"","code":"# 1. Define the desired JSON structure using s_* functions my_schema_definition <- s_map(   product_id = s_string(),   quantity = s_integer(),   in_stock = s_logical(),   attributes = s_vector(s_string()) )  # 2. Finalize and validate the definition finalized_structure <- build_structure(my_schema_definition) # finalized_structure is now ready to be used with parse_json()  # Example with nested structures complex_definition <- s_map(   order_id = s_integer(),   customer = s_map(     name = s_string(),     email = s_string()   ),   items = s_vector(     s_map(       sku = s_string(),       price = s_double()     )   ) )  validated_complex_structure <- build_structure(complex_definition)  # Use the built structure with parse_json (see ?parse_json examples) json_data <- '{   \"product_id\": \"XYZ-123\",   \"quantity\": 5,   \"in_stock\": true,   \"attributes\": [\"red\", \"large\"] }' parsed_data <- parse_json(json_data, structure = finalized_structure) print(parsed_data) #> $product_id #> [1] \"XYZ-123\" #>  #> $quantity #> [1] 5 #>  #> $in_stock #> [1] TRUE #>  #> $attributes #> [1] \"red\"   \"large\" #>"},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse and Validate JSON Against a Structure — parse_json","title":"Parse and Validate JSON Against a Structure — parse_json","text":"Parses JSON string validates schema created build_structure(). Returns R object reflecting JSON content valid, throws detailed error.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse and Validate JSON Against a Structure — parse_json","text":"","code":"parse_json(json_string, structure)"},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse and Validate JSON Against a Structure — parse_json","text":"json_string character string containing JSON input. structure structure definition created build_structure(), based s_* functions.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse and Validate JSON Against a Structure — parse_json","text":"parsed validated data R object: JSON objects → named lists JSON arrays → unnamed lists Strings, numbers, booleans → scalar R values (character, numeric, integer, logical) Errors raised invalid syntax, type mismatches, missing extra fields, duplicate keys, integer overflows.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse and Validate JSON Against a Structure — parse_json","text":"Validation checks include: Types: JSON values must match declared structure (e.g., string vs integer). Required fields: fields s_map() must present. extra fields: Additional fields structure cause errors (unless .ignore_extra_fields = TRUE). Duplicate keys: Disallowed. Integer range: Must fit within R's 32-bit integer limits s_integer(). Homogeneous arrays: Elements s_vector() must match defined structure. Parsing powered serde_json Rust performance.","code":""},{"path":"https://ixpantia.github.io/structr/reference/parse_json.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse and Validate JSON Against a Structure — parse_json","text":"","code":"# Define and build a structure schema <- build_structure(s_map(   id = s_integer(),   username = s_string(),   is_active = s_logical(),   scores = s_vector(s_double()) ))  # Valid input json <- '{\"id\":1,\"username\":\"user\",\"is_active\":true,\"scores\":[9.5,8.0]}' parse_json(json, schema) #> $id #> [1] 1 #>  #> $username #> [1] \"user\" #>  #> $is_active #> [1] TRUE #>  #> $scores #> [1] 9.5 8.0 #>   # Common errors: # - Invalid JSON # - Wrong type (e.g., \"id\": \"abc\") # - Missing fields # - Unexpected extra fields # - Integer overflow # - Duplicate keys"},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a Date Structure — s_date","title":"Define a Date Structure — s_date","text":"Creates intermediate definition JSON date. typically used within s_map() define fields contain date values.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a Date Structure — s_date","text":"","code":"s_date(format = \"%Y-%m-%d\")"},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a Date Structure — s_date","text":"format date format string. single string specifies expected format date JSON data. format compatible strftime function R. example, \"%Y-%m-%d\" \"2023-10-01\".","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a Date Structure — s_date","text":"intermediate list representing date structure definition.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a Map (Object) Structure — s_map","title":"Define a Map (Object) Structure — s_map","text":"Creates structure definition JSON object named fields. field must defined using s_* function (e.g., s_string(), s_integer(), nested structures).","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a Map (Object) Structure — s_map","text":"","code":"s_map(..., .ignore_extra_fields = FALSE)"},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a Map (Object) Structure — s_map","text":"... Named field definitions. name corresponds key JSON object, value must structure created s_* function. Call s_map() arguments define empty object. .ignore_extra_fields Logical (default FALSE). TRUE, allows extra fields input JSON ignored instead triggering validation error.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a Map (Object) Structure — s_map","text":"intermediate structure definition used build_structure().","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a Map (Object) Structure — s_map","text":"","code":"# Simple object s_map(name = s_string(), age = s_integer()) #> $type #> [1] \"map\" #>  #> $value #> $value$name #> $value$name$type #> [1] \"string\" #>  #>  #> $value$age #> $value$age$type #> [1] \"integer\" #>  #>  #>  #> $ignore_extra_fields #> [1] FALSE #>   # Nested structure s_map(   user = s_string(),   details = s_map(email = s_string(), active = s_logical()),   tags = s_vector(s_string()) ) #> $type #> [1] \"map\" #>  #> $value #> $value$user #> $value$user$type #> [1] \"string\" #>  #>  #> $value$details #> $value$details$type #> [1] \"map\" #>  #> $value$details$value #> $value$details$value$email #> $value$details$value$email$type #> [1] \"string\" #>  #>  #> $value$details$value$active #> $value$details$value$active$type #> [1] \"logical\" #>  #>  #>  #> $value$details$ignore_extra_fields #> [1] FALSE #>  #>  #> $value$tags #> $value$tags$type #> [1] \"vector\" #>  #> $value$tags$value #> $value$tags$value$type #> [1] \"string\" #>  #>  #>  #>  #> $ignore_extra_fields #> [1] FALSE #>   # Ignore extra JSON fields s_map(id = s_integer(), .ignore_extra_fields = TRUE) #> $type #> [1] \"map\" #>  #> $value #> $value$id #> $value$id$type #> [1] \"integer\" #>  #>  #>  #> $ignore_extra_fields #> [1] TRUE #>"},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":null,"dir":"Reference","previous_headings":"","what":"Define an Optional (Nullable) Structure — s_optional","title":"Define an Optional (Nullable) Structure — s_optional","text":"Creates intermediate definition indicating JSON value can either conform specified structure_definition JSON null. typically used within s_map() define fields required non-null value.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an Optional (Nullable) Structure — s_optional","text":"","code":"s_optional(structure_definition)"},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an Optional (Nullable) Structure — s_optional","text":"structure_definition structure definition JSON value conform null. result another s_* function call (e.g., s_integer(), s_string(), s_map(...)).","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define an Optional (Nullable) Structure — s_optional","text":"intermediate list representing optional structure definition.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_optional.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define an Optional (Nullable) Structure — s_optional","text":"","code":"# Define a map where 'description' is optional (can be string or null) map_with_optional <- s_map(   id = s_integer(),   description = s_optional(s_string()) ) built_optional <- build_structure(map_with_optional) str(built_optional) #> Class 'Structure' <externalptr>  # Expected (simplified): # list(type = \"map\", #      value = list(id = list(type = \"integer\"), #                   description = list(type = \"optional\", #                                      value = list(type = \"string\"))), #      ...)  # Define a vector where elements can be integers or null vec_optional_elements <- s_vector(s_optional(s_integer())) build_structure(vec_optional_elements) #> Vector( #>     Optional( #>         Integer, #>     ), #> ) # Expected (simplified): # list(type = \"vector\", #      value = list(type = \"optional\", value = list(type = \"integer\")))  # --- Parsing Examples (see ?parse_json) ---  # Field present and valid json_present <- '{\"id\": 1, \"description\": \"A product\"}' parse_json(json_present, built_optional) #> $id #> [1] 1 #>  #> $description #> [1] \"A product\" #>  # Output: list(id = 1L, description = \"A product\")  # Optional field is null json_null <- '{\"id\": 2, \"description\": null}' parse_json(json_null, built_optional) #> $id #> [1] 2 #>  #> $description #> NULL #>  # Output: list(id = 2L, description = NULL)  # Optional field is missing (this causes an error by default with maps) # Note: Optionality here means \"can be null\", not \"can be absent\". # The 'missing field' error takes precedence unless the field is truly absent # from the structure definition itself (which isn't the case here). json_missing <- '{\"id\": 3}' try(parse_json(json_missing, built_optional)) #> $id #> [1] 3 #>  # Expected: Error about missing field \"description\"  # Parsing a vector with optional elements json_vec_opt <- '[10, null, 30, null]' parse_json(json_vec_opt, build_structure(vec_optional_elements)) #> [1] 10 NA 30 NA # Output: list(10L, NULL, 30L, NULL)"},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a Vector (Array) Structure — s_vector","title":"Define a Vector (Array) Structure — s_vector","text":"Creates intermediate definition JSON array elements must conform specified element_structure. definition used within s_map() finalized build_structure().","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a Vector (Array) Structure — s_vector","text":"","code":"s_vector(element_structure)"},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a Vector (Array) Structure — s_vector","text":"element_structure structure definition elements within vector. result another s_* function call (e.g., s_integer(), s_map(id = s_integer())).","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a Vector (Array) Structure — s_vector","text":"intermediate list representing vector structure definition.","code":""},{"path":"https://ixpantia.github.io/structr/reference/s_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a Vector (Array) Structure — s_vector","text":"","code":"# Define a vector of strings vec_str_def <- s_vector(s_string()) build_structure(vec_str_def) #> Vector( #>     String, #> ) # Expected: list(type = \"vector\", value = list(type = \"string\"))  # Define a vector of objects, each having an 'id' (integer) and 'name' (string) vec_obj_def <- s_vector(   s_map(id = s_integer(), name = s_string()) ) build_structure(vec_obj_def) #> Vector( #>     Map { #>         fields: { #>             \"name\": String, #>             \"id\": Integer, #>         }, #>         ignore_extra_fields: false, #>         expected_fields_str: [ #>             \"name\", #>             \"id\", #>         ], #>     }, #> ) # Expected: list(type = \"vector\", value = list(type = \"map\", #                   value = list(id = list(type = \"integer\"), #                                name = list(type = \"string\"))))  # Parsing example (see ?parse_json) json_data <- '[{\"id\": 1, \"name\": \"A\"}, {\"id\": 2, \"name\": \"B\"}]' parsed <- parse_json(json_data, build_structure(vec_obj_def)) print(parsed) # Will be a list of lists #> [[1]] #> [[1]]$id #> [1] 1 #>  #> [[1]]$name #> [1] \"A\" #>  #>  #> [[2]] #> [[2]]$id #> [1] 2 #>  #> [[2]]$name #> [1] \"B\" #>  #>"},{"path":"https://ixpantia.github.io/structr/reference/serialize_json.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize data to JSON — serialize_json","title":"Serialize data to JSON — serialize_json","text":"function serializes R data JSON format using specified structure. main purpose provide type-safe way convert R objects JSON strings conform predefined structure. Since R array language, many typical serialization tasks can make interoperability languages difficult. uncommon API expect scalar value, R serialize length-1 vector. function designed handle cases providing structure defines expected types formats data. structure defined using build_structure function, allows specify types field data. function serialize data according structure, ensuring output correct format.","code":""},{"path":"https://ixpantia.github.io/structr/reference/serialize_json.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize data to JSON — serialize_json","text":"","code":"serialize_json(data, structure, pretty = FALSE)"},{"path":"https://ixpantia.github.io/structr/reference/serialize_json.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serialize data to JSON — serialize_json","text":"data data serialize structure structure use serialization pretty Whether pretty-print JSON","code":""},{"path":"https://ixpantia.github.io/structr/reference/serialize_json.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serialize data to JSON — serialize_json","text":"JSON string","code":""},{"path":"https://ixpantia.github.io/structr/reference/serialize_json.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serialize data to JSON — serialize_json","text":"","code":"# Example usage data <- list(name = \"Test\", value = 123L, active = TRUE) structure <- build_structure(s_map(   name = s_string(),   value = s_integer(),   active = s_logical() )) json_string <- serialize_json(data, structure) print(json_string) #> {\"name\":\"Test\",\"value\":123,\"active\":true}"},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":null,"dir":"Reference","previous_headings":"","what":"Define Atomic Structure Types — structure_atomics","title":"Define Atomic Structure Types — structure_atomics","text":"functions create intermediate definitions basic JSON atomic types (integer, number/double, string, boolean). definitions used within s_vector() s_map() finalized build_structure().","code":""},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define Atomic Structure Types — structure_atomics","text":"","code":"s_integer()  s_double()  s_string()  s_logical()"},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define Atomic Structure Types — structure_atomics","text":"intermediate list representing atomic type definition (e.g., list(type = \"integer\")).","code":""},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define Atomic Structure Types — structure_atomics","text":"s_integer(): Expects JSON integer fits within R's 32-bit signed integer range. Allows JSON numbers without fractional parts (e.g., 123.0). s_double(): Expects JSON number (integer float). s_string(): Expects JSON string. s_logical(): Expects JSON boolean (true false).","code":""},{"path":"https://ixpantia.github.io/structr/reference/structure_atomics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define Atomic Structure Types — structure_atomics","text":"","code":"build_structure(s_integer()) # list(type = \"integer\") #> Integer build_structure(s_double())  # list(type = \"double\") #> Double build_structure(s_string())  # list(type = \"string\") #> String build_structure(s_logical()) # list(type = \"logical\") #> Logical"}]
